#!/usr/bin/env node
'use strict';

const chalk = require('chalk');
const meow = require('meow');
const Listr = require('listr');
const inquirer = require('inquirer');
const ghGot = require('gh-got');
const travisGot = require('./lib/travis-got');
const GitHubPublisher = require('github-publish');
const rsa = require('ursa');
const yaml = require('js-yaml');
const clone = require('clone');
const deepEqual = require('fast-deep-equal');
// const foo = require('.');

const pkg = require('./package.json');

const TRAVIS_YAML_AUTO_CREATED_COMMENT = '# Auto-generated by travis-env-sync\n';
const KEYCHAIN_SERVICE = 'travis-env-sync';

let keytar;

try {
  keytar = require('keytar');
} catch (e) {}

const userAgent = pkg.name.replace(/^@[^/]*\//, '') + '/' + pkg.version + (pkg.homepage ? ' (' + pkg.homepage + ')' : '');
const headers = Object.freeze({
  'User-Agent': userAgent
});

const cli = meow(`
    Usage
      $ travis-env-sync <input>

    Options
      --keychain, -k  Use tokens from keychain
      --reset, -r     Reset tokens in keychain

    Examples
      $ travis-env-sync --keychain
`, {
    flags: {
      keychain: {
        type: 'boolean',
        alias: 'k'
      },
      reset: {
        type: 'boolean',
        alias: 'r'
      }
    }
  }
);

const useKeychain = keytar && cli.flags.keychain;

// const justSomeDelay = () => new Promise(resolve => setTimeout(resolve, 1000));

// const logThen = (value) => { console.log(value); return value; };

const getTokens = (tokens) => {
  return (useKeychain ? keytar.findCredentials(KEYCHAIN_SERVICE) : Promise.resolve([]))
    .then(result => cli.flags.reset
      ? Promise.all(result.map(item => keytar.deletePassword(KEYCHAIN_SERVICE, item.account)))
        .then(() => ({}))
      : result.reduce((result, item) => {
        result[item.account] = item.password;
        return result;
      }, {})
    )
    .then(credentials => {
      const result = {};
      const prompts = [];

      Object.keys(tokens).forEach(resultName => {
        const [ tokenIdentifier, tokenDescription ] = tokens[resultName] || [];

        if (!tokenIdentifier) { return; }

        if (credentials[tokenIdentifier]) {
          result[resultName] = credentials[tokenIdentifier];
        } else {
          prompts.push({
            type: 'password',
            message: tokenDescription,
            name: resultName
          });
        }
      });

      return (prompts.length ? inquirer.prompt(prompts) : Promise.resolve({}))
        .then(promptResults => {
          if (useKeychain) {
            Object.keys(promptResults).forEach(resultName => {
              keytar.setPassword(KEYCHAIN_SERVICE, tokens[resultName][0], promptResults[resultName]);
            });
          }
          return Object.assign(result, promptResults);
        });
    });
};

const getSecretLessTravisFile = (file) => {
  const result = clone(file);

  const notification = (((result.notifications || {}).slack || {}).rooms || [])[0] || {};
  delete notification.secure;

  return result;
};

const getListrTaskForRepo = (repo, { travisToken, npmToken, gitHubToken, slackToken, slackAccount, baseTravisYaml }) => {
  const context = {};
  const encodedRepo = encodeURIComponent(repo);
  const [repoOwner, repoName] = repo.split('/');
  // TODO: Make "private" configurable
  const baseTravisGotOptions = Object.freeze({ token: travisToken, private: true, headers });
  const ghPublisher = new GitHubPublisher(gitHubToken, repoOwner, repoName);
  const skipSlackNotification = !slackToken || !slackAccount;

  return new Listr([
    {
      title: 'Check repo Travis status',
      task: (ctx, task) => travisGot(`repo/${encodedRepo}`, baseTravisGotOptions)
        .then(result => {
          context.active = !!result.body.active;
          task.title = task.title + ': ' + (context.active ? chalk.green('Active') : chalk.red('Inactive'));
        })
    },
    {
      title: 'Set repo settings on Travis',
      task: () => travisGot.patch(`repo/${encodedRepo}/setting/builds_only_with_travis_yml`, Object.assign({
        body: { 'setting.value': true }
      }, baseTravisGotOptions))
        .then(() => {})
    },
    {
      title: 'Set env variable on Travis',
      task: () => new Listr([
        {
          title: 'Fetch existing env variables',
          task: (ctx, task) => travisGot(`repo/${encodedRepo}/env_vars`, baseTravisGotOptions)
            .then(result => {
              context.npmEnvVar = result.body.env_vars.find(item => item.name === 'NPM_TOKEN');
              task.title = task.title + ': ' + (context.npmEnvVar ? chalk.green('Found') : chalk.red('Not found'));
            })
        },
        // TODO: Make extendable â€“ don't hard code NPM_TOKEN here, leave it to be configurable
        {
          title: 'Save NPM token',
          task: (ctx, task) => {
            const body = {
              'env_var.name': 'NPM_TOKEN',
              'env_var.value': npmToken,
              'env_var.public': false
            };

            if (context.npmEnvVar) {
              task.title = 'Update NPM token';
              return travisGot.patch(`repo/${encodedRepo}/env_var/${context.npmEnvVar.id}`, Object.assign({ body }, baseTravisGotOptions))
                .then(() => {});
            }

            task.title = 'Add NPM token';

            return travisGot.post(`repo/${encodedRepo}/env_vars`, Object.assign({ body }, baseTravisGotOptions))
              .then(() => {});
          }
        }
      ])
    },
    {
      title: 'Activate repo on Travis',
      skip: () => context.active === true,
      task: () => travisGot.post(`repo/${encodedRepo}/activate`, baseTravisGotOptions)
        .then(() => {})
    },
    {
      title: 'Set a .travis.yml to GitHub',
      task: () => new Listr([
        {
          title: 'Fetch required data',
          task: () => new Listr([
            {
              title: 'Fetch current file',
              task: () => ghPublisher.retrieve('.travis.yml')
                .then(({ content, sha }) => {
                  if (!content) { return; }

                  if (content.startsWith(TRAVIS_YAML_AUTO_CREATED_COMMENT)) {
                    context.currentTravisFile = yaml.safeLoad(content);
                    context.currentTravisSha = sha;
                  } else {
                    context.skipTravisFileUpdate = true;
                  }
                })
            },
            {
              title: 'Fetch public key',
              skip: () => skipSlackNotification,
              task: () => travisGot(`repo/${encodedRepo}/key_pair/generated`, baseTravisGotOptions)
                .then(result => { context.travisPublicKey = result.body.public_key; })
            }
          ])
        },
        {
          title: 'Encode values',
          skip: () => skipSlackNotification || context.skipTravisFileUpdate,
          task: () => {
            const publicKey = rsa.createPublicKey(context.travisPublicKey);
            const encryptedSlackCredentials = publicKey.encrypt(slackAccount + ':' + slackToken, undefined, undefined, rsa.RSA_PKCS1_PADDING);
            context.encryptedSlackCredentials = encryptedSlackCredentials.toString('base64');
          }
        },
        {
          title: 'Create .travis.yml content',
          skip: () => context.skipTravisFileUpdate,
          task: () => {
            const travisYaml = clone(baseTravisYaml);

            if (context.encryptedSlackCredentials) {
              travisYaml.notifications = travisYaml.notifications || {};
              travisYaml.notifications.slack = travisYaml.notifications.slack || {};
              travisYaml.notifications.slack.rooms = travisYaml.notifications.slack.rooms || {};

              travisYaml.notifications.slack.rooms = [
                { secure: context.encryptedSlackCredentials }
              ];
            }

            context.newTravisFile = travisYaml;
          }
        },
        {
          title: 'Push .travis.yml if changed',
          skip: () => {
            if (context.skipTravisFileUpdate) { return true; }
            if (!context.currentTravisFile) { return false; }

            const secretLessNew = getSecretLessTravisFile(context.newTravisFile);
            const secretLessCurrent = getSecretLessTravisFile(context.currentTravisFile);

            return deepEqual(secretLessNew, secretLessCurrent);
          },
          task: () => {
            const yamlData = TRAVIS_YAML_AUTO_CREATED_COMMENT +
              yaml.safeDump(context.newTravisFile);

            return ghPublisher.publish('.travis.yml', yamlData, {
              sha: context.currentTravisSha,
              message: 'updating Travis CI conf through travis-env-sync'
            });
          }
        }
      ])
    }
  ]);
};

// TODO: Read this stuff + the env-variables to add from a config file
const repos = [
  // 'Sydsvenskan/eshu',
  'Sydsvenskan/node-config-loader'
];

const slackAccount = 'hdsydsvenskan';

const baseTravisYaml = {
  'language': 'node_js',
  'node_js': ['8', '6'],
  'sudo': false,
  'before_install': [
    // eslint-disable-next-line no-template-curly-in-string
    'echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > .npmrc'
  ]
};

getTokens({
  travisToken: ['Travis Access Token', 'Travis Access Token'],
  gitHubToken: ['GitHub Write Access Token', 'GitHub Write Access Token'],
  npmToken: ['NPM Token', 'NPM Token'],
  slackToken: slackAccount ? ['Slack Token', 'Slack Token'] : false
})
  .then(({ travisToken, gitHubToken, npmToken, slackToken }) => new Listr([
    {
      title: 'Verifying access credentials',
      task: () => {
        return new Listr([
          {
            title: 'Travis CI Access Token',
            task: () => travisGot('user', { token: travisToken, private: true, headers })
              .then(answer => answer.body.name)
          },
          {
            title: 'GitHub Access Token',
            task: () => ghGot('user', { token: gitHubToken, headers })
              .then(answer => answer.body.name)
          }
        ], { concurrent: true });
      }
    },
    {
      title: 'Updating repository setups',
      task: () => new Listr(
        repos.map(key => ({
          title: `Repo ${key}`,
          task: () => getListrTaskForRepo(key, { travisToken, npmToken, gitHubToken, slackToken, slackAccount, baseTravisYaml })
        })),
        { concurrent: 3 }
      )
    }
  ]))
  .then(tasks => tasks.run())
  // .catch(err => {
  //   console.log('ðŸ˜±', err);
  //   return Promise.reject(err);
  // })
  .catch(() => {
    process.exit(1);
  });
