#!/usr/bin/env node
'use strict';

const chalk = require('chalk');
const meow = require('meow');
const Listr = require('listr');
const inquirer = require('inquirer');
const ghGot = require('gh-got');
const travisGot = require('./lib/travis-got');
const GitHubPublisher = require('github-publish');
const rsa = require('ursa');
const yaml = require('js-yaml');
const clone = require('clone');
const deepEqual = require('fast-deep-equal');
const promisify = require('util.promisify');
const fs = require('fs');
const getStdin = require('get-stdin');
// const foo = require('.');

const pkg = require('./package.json');

const TRAVIS_YAML_AUTO_CREATED_COMMENT = '# Auto-generated by travis-env-sync\n';
const KEYCHAIN_SERVICE = 'travis-env-sync';
const ENV_VAR_TOKEN_PREFIX = 'ENV_';

let keytar;

try {
  keytar = require('keytar');
} catch (e) {}

const userAgent = pkg.name.replace(/^@[^/]*\//, '') + '/' + pkg.version + (pkg.homepage ? ' (' + pkg.homepage + ')' : '');
const headers = Object.freeze({
  'User-Agent': userAgent
});

const getSecretLessTravisFile = (file) => {
  const result = clone(file);

  const notification = (((result.notifications || {}).slack || {}).rooms || [])[0] || {};
  delete notification.secure;

  return result;
};

const cli = meow(`
    Usage
      $ travis-env-sync <configuration-file>

    Options
      --keychain, -k      Use tokens from keychain
      --reset, -r         Reset tokens in keychain

    Examples
      $ travis-env-sync -k </path/to/conf.yml>
`, {
    flags: {
      keychain: {
        type: 'boolean',
        alias: 'k'
      },
      reset: {
        type: 'boolean',
        alias: 'r'
      }
    }
  }
);

const configFilePath = cli.input[0];
const useKeychain = keytar && cli.flags.keychain;

const getTokens = (tokens) => {
  return (useKeychain ? keytar.findCredentials(KEYCHAIN_SERVICE) : Promise.resolve([]))
    .then(result => cli.flags.reset
      ? Promise.all(result.map(item => keytar.deletePassword(KEYCHAIN_SERVICE, item.account)))
        .then(() => ({}))
      : result.reduce((result, item) => {
        result[item.account] = item.password;
        return result;
      }, {})
    )
    .then(credentials => {
      const result = {};
      const prompts = [];

      Object.keys(tokens).forEach(resultName => {
        const [ tokenIdentifier, tokenDescription ] = tokens[resultName] || [];

        if (!tokenIdentifier) { return; }

        if (credentials[tokenIdentifier]) {
          result[resultName] = credentials[tokenIdentifier];
        } else {
          prompts.push({
            type: 'password',
            message: tokenDescription,
            name: resultName
          });
        }
      });

      return (prompts.length ? inquirer.prompt(prompts) : Promise.resolve({}))
        .then(promptResults => {
          if (useKeychain) {
            Object.keys(promptResults).forEach(resultName => {
              keytar.setPassword(KEYCHAIN_SERVICE, tokens[resultName][0], promptResults[resultName]);
            });
          }
          return Object.assign(result, promptResults);
        });
    });
};

const getListrTaskForRepo = (repo, { config, tokens }) => {
  const { travisToken, gitHubToken, slackToken } = tokens;
  const context = {};
  const encodedRepo = encodeURIComponent(repo);
  const [repoOwner, repoName] = repo.split('/');
  const baseTravisGotOptions = Object.freeze({ token: travisToken, private: !!config.private_travis, headers });
  const ghPublisher = new GitHubPublisher(gitHubToken, repoOwner, repoName);
  const skipSlackNotification = !slackToken || !config.slack;

  return new Listr([
    {
      title: 'Check repo Travis status',
      task: (ctx, task) => travisGot(`repo/${encodedRepo}`, baseTravisGotOptions)
        .then(result => {
          context.active = !!result.body.active;
          task.title = task.title + ': ' + (context.active ? chalk.green('Active') : chalk.red('Inactive'));
        })
    },
    {
      title: 'Set repo settings on Travis',
      task: () => {
        const tasks = [{
          title: 'Only build when there\'s a .travis.yml file',
          task: () => travisGot.patch(`repo/${encodedRepo}/setting/builds_only_with_travis_yml`, Object.assign({
            body: { 'setting.value': true }
          }, baseTravisGotOptions))
            .then(() => {})
        }];

        if (config.cron) {
          tasks.push({
            title: 'Set cron on master',
            task: () => travisGot.post(`repo/${encodedRepo}/branch/master/cron`, Object.assign({
              body: {
                'cron.interval': config.cron,
                'cron.dont_run_if_recent_build_exists': true
              }
            }, baseTravisGotOptions))
              .then(() => {})
          });
        }

        return new Listr(tasks, { concurrent: true });
      }
    },
    {
      title: 'Set env variable on Travis',
      task: () => new Listr([
        {
          title: 'Fetch existing env variables',
          task: (ctx, task) => travisGot(`repo/${encodedRepo}/env_vars`, baseTravisGotOptions)
            .then(result => {
              const secretEnvVars = config.secret_env_vars || [];

              context.existingSecretEnvVars = result.body.env_vars.reduce((result, item) => {
                if (secretEnvVars.includes(item.name)) {
                  result[item.name] = item;
                }
                return result;
              }, {});
            })
        },
        {
          title: 'Set secret env variables',
          task: (ctx, task) => new Listr((config.secret_env_vars || []).map(envVar => {
            return {
              title: 'Set ' + envVar,
              task: (ctx, task) => {
                const body = {
                  'env_var.name': envVar,
                  'env_var.value': tokens[ENV_VAR_TOKEN_PREFIX + envVar],
                  'env_var.public': false
                };

                const existing = context.existingSecretEnvVars[envVar];

                if (existing) {
                  task.title = 'Update ' + envVar;
                  return travisGot.patch(`repo/${encodedRepo}/env_var/${existing.id}`, Object.assign({ body }, baseTravisGotOptions))
                    .then(() => {});
                }

                task.title = 'Add ' + envVar;

                return travisGot.post(`repo/${encodedRepo}/env_vars`, Object.assign({ body }, baseTravisGotOptions))
                  .then(() => {});
              }
            };
          }), { concurrent: true })
        }
      ])
    },
    {
      title: 'Activate repo on Travis',
      skip: () => context.active === true,
      task: () => travisGot.post(`repo/${encodedRepo}/activate`, baseTravisGotOptions)
        .then(() => {})
    },
    {
      title: 'Set a .travis.yml to GitHub',
      task: () => new Listr([
        {
          title: 'Fetch required data',
          task: () => new Listr([
            {
              title: 'Fetch current file',
              task: () => ghPublisher.retrieve('.travis.yml')
                .then(({ content, sha }) => {
                  if (!content) { return; }

                  if (content.startsWith(TRAVIS_YAML_AUTO_CREATED_COMMENT)) {
                    context.currentTravisFile = yaml.safeLoad(content);
                    context.currentTravisSha = sha;
                  } else {
                    context.skipTravisFileUpdate = true;
                  }
                })
            },
            {
              title: 'Fetch public key',
              skip: () => skipSlackNotification,
              task: () => travisGot(`repo/${encodedRepo}/key_pair/generated`, baseTravisGotOptions)
                .then(result => { context.travisPublicKey = result.body.public_key; })
            }
          ])
        },
        {
          title: 'Encode values',
          skip: () => skipSlackNotification || context.skipTravisFileUpdate,
          task: () => {
            const publicKey = rsa.createPublicKey(context.travisPublicKey);
            const encryptedSlackCredentials = publicKey.encrypt(config.slack + ':' + slackToken, undefined, undefined, rsa.RSA_PKCS1_PADDING);
            context.encryptedSlackCredentials = encryptedSlackCredentials.toString('base64');
          }
        },
        {
          title: 'Create .travis.yml content',
          skip: () => context.skipTravisFileUpdate,
          task: () => {
            const travisYaml = clone(config.travis);

            if (context.encryptedSlackCredentials) {
              travisYaml.notifications = travisYaml.notifications || {};
              travisYaml.notifications.slack = travisYaml.notifications.slack || {};
              travisYaml.notifications.slack.rooms = travisYaml.notifications.slack.rooms || {};

              travisYaml.notifications.slack.rooms = [
                { secure: context.encryptedSlackCredentials }
              ];
            }

            context.newTravisFile = travisYaml;
          }
        },
        {
          title: 'Push .travis.yml if changed',
          skip: () => {
            if (context.skipTravisFileUpdate) { return true; }
            if (!context.currentTravisFile) { return false; }

            const secretLessNew = getSecretLessTravisFile(context.newTravisFile);
            const secretLessCurrent = getSecretLessTravisFile(context.currentTravisFile);

            return deepEqual(secretLessNew, secretLessCurrent);
          },
          task: () => {
            const yamlData = TRAVIS_YAML_AUTO_CREATED_COMMENT +
              yaml.safeDump(context.newTravisFile);

            return ghPublisher.publish('.travis.yml', yamlData, {
              sha: context.currentTravisSha,
              message: 'updating Travis CI conf through travis-env-sync'
            });
          }
        }
      ])
    }
  ]);
};

(configFilePath ? promisify(fs.readFile)(configFilePath) : getStdin())
  .then(yamlContent => yaml.safeLoad(yamlContent))
  .then(config => {
    const tokens = {
      travisToken: ['Travis Access Token', 'Travis Access Token'],
      gitHubToken: ['GitHub Write Access Token', 'GitHub Write Access Token'],
      slackToken: config.slack ? ['Slack Token', 'Slack Token'] : false
    };
    (config.secret_env_vars || []).forEach(value => {
      tokens[ENV_VAR_TOKEN_PREFIX + value] = ['Env variable ' + value, 'Env variable ' + value];
    });
    return getTokens(tokens)
      .then(tokens => ({ config, tokens }));
  })
  .then(({ config, tokens }) => new Listr([
    {
      title: 'Verifying access credentials',
      task: () => {
        return new Listr([
          {
            title: 'Travis CI Access Token',
            task: () => travisGot('user', { token: tokens.travisToken, private: true, headers })
              .then(answer => answer.body.name)
          },
          {
            title: 'GitHub Access Token',
            task: () => ghGot('user', { token: tokens.gitHubToken, headers })
              .then(answer => answer.body.name)
          }
        ], { concurrent: true });
      }
    },
    {
      title: 'Updating repository setups',
      task: () => new Listr(
        (config.repos || []).map(key => ({
          title: `Repo ${key}`,
          task: () => getListrTaskForRepo(key, { config, tokens })
        })),
        { concurrent: 3 }
      )
    }
  ]))
  .then(tasks => tasks.run())
  // .catch(err => {
  //   console.log('😱', err);
  //   return Promise.reject(err);
  // })
  .catch(() => {
    process.exit(1);
  });
